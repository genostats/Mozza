
*****************************************************
*             Classe mozza::mosaic                  *
*        Fichiers mosaic.h mosaic*.cpp              *
*              et human_autosomes.h                 *
*****************************************************


La classe mosaic définie dans mosaic.h permet de créer des haplotypes
mosaïque. Les membres sont "documentés" dans la classe.

Les haplotypes mosaiques sont des vecteurs d'entiers... 

* infos sur les chromosomes

  int chrs; // nombre de chromosomes (eg 22)
  // référence à un vecteur de chrs (22) longueurs (en cM...)
  const std::vector<double> & chr_len;

  // longueur totale des chromosomes
  double genome_length;


* des vecteurs pour les tuiles 

  // un vecteur de chrs (22) vecteurs de 'tiles'
  std::vector<std::vector<int>> tiles;

  // idem avec les points de coupure (en cM) entre les tuiles
  // NB Il y a toujours un bpoint en fin de chr, sa position doit coincider avec chr_len[chr]
  std::vector<std::vector<double>> bpoints;


* position d'un "curseur" qui pointe un endroit du génome.
* Le i_cursor est l'indice (dans les vecteurs de tuiles) de la tuile pointée
* par le curseur

  // position du curseur
  unsigned int cursor_chr;
  double cursor_pos; // en cM
  unsigned int i_cursor;


* Constructeurs. Le premier construit des haplotypes avec une seule tuile.
* Le second mélange deux haplotypes mosaiques préexistant en y piochant des
* morceaux de longueurs prises dans des lois exp (les longueurs sont en cM)
* Le troisième et le quatrième font une mosaïque à la hapgen
* Le code est dans mosaic.cpp

  // constructeur avec la tuile tile (0) répétée sur tous les chrs
  mosaic(const std::vector<double> & chr_len, int tile = 0);

  // constructeur par mélange 
  // le1, le2 = longueur moyenne des morceaux (loi exp) des deux haplotypes d'origine
  // sauf erreur les valeurs par défaut correspondent à la meiose (morceaux d'un morgan)
  mosaic(mosaic & M1, mosaic & M2, double le1 = 100., double l2 = 100.);

  // constructeur avec des tuiles tirée uniforméments entre 0 et (ntiles - 1), 
  // de longueurs prises dans une loi exp lambda = 1/mean_length
  // [truc à la hapgen]
  mosaic(const std::vector<double> & chr_len, int ntiles, double mean_length);

  // constructeur avec des tuiles de 0 à proba_tiles.size()-1, 
  // de longueur prise dans une exponentielle comme ci-dessus
  // d'indices tirés selon les valeurs du vecteur proba_tiles
  mosaic::mosaic(const std::vector<double> & chr_len, const std::vector<double> & proba_tiles, double mean_length);

* NOTE
* On peut utiliser pour l'argument chr_len des constructeurs 1 et 3
* le vecteur mozza::human_autosomes_b37
* qui est défini dans human_autosomes.h
* ainsi que mozza::length_human_autosomes_b37  (la somme des longueurs)

* Fonctions de gestion du curseur. Utilisées par les fonctions qui calculent l'IBD
* Le code est dans mosaic_cursor.cpp

  // positionner le curseur
  void set_cursor(unsigned int chr = 0, double pos = 0.);

  // avancer le curseur [en récupérant ou pas les tuiles et les break points rencontrées sur le chemin]
  void step_cursor(double length); // avance de length
  void forward_cursor(double pos); // avance jusqu'à pos (supposé > cursor_pos, sinon on bouge pas)

  // idem step cursor mais push_back dans til et pbt les numéros de tuiles et les positions de bpoints
  // "dépassés sur le chemin"
  void step_cursor(double length, std::vector<int> & til, std::vector<double> & bpt);

  // numéro de la tuile au curseur
  int tile_at_cursor();

* Fonctions d'affichage rudimentaire...
* Le code est dans mosaic_print.cpp

  void print();
  void print_chr(int i);
  void print_cursor();

*****************************************************
*             Classe mozza::zygote                  *
*               Fichier zygote.h                    *
*****************************************************

* Cette classe est juste un moyen d'éviter d'écrire std::pair<mosaic,mosaic>
* Les membres sont donc .first et .second

* Constructeur zygote(mosaic h1, mosaic h2) : crée la paire

* Le constructeur zygote(const std::vector<double> & chr_len, int ntiles, double mean_length)
* appelle le constructeur "à la hapgen" pour créer les deux haplotypes

* Idem pour zygote(const std::vector<double> & chr_len, const std::vector<double> & proba_tiles, double mean_length)

* Fonction + : appelle le "constructeur méiotique" pour faire un enfant


*****************************************************
*    Fonctions                                      *
*          mozza::sharing                           *
*          mozza::IBD_length                        *
*          mozza::kinship_matrix                    *
*          mozza::zygote_to_bed_matrix              *
*          mozza::haplo_to_bed_matrix               *
*    Fichiers mozza.h et                            *
*          sharing.cpp                              *
*          ibd.cpp                                  *
*          kinship_matrix.cpp                       *
*          faternity_matrix.cpp                     *
*          zygote_to_bed_matrix.h                   * 
*****************************************************


double sharing(mosaic & M1, mosaic & M2)l

* calcule la longueur IBD entre haplotypes M1 et M2
* cette fonction (comme les suivantes) modifie la valeur du curseur


std::tuple<double, double, double> IBD_length(zygote & Z1, zygote & Z2);

* Renvoie un triplet avec les longueurs des portions de génome avec 
* IBD 0, 1 et 2. La fonction ne vérifie pas que tous les haplotypes sont
* construits sur des génomes de même structure... 
* [ pour bien faire il faudrait ne pas avoir cette structure stockée
*   les haplotypes mosaique ... et de même il faudrait avoir un 
*   seul curseur pour tous les haplotypes ... ]


NumericMatrix kinship_matrix(std::vector<zygote> & ZYG);

* Prend un vecteur de zygotes et renvoie la matrice de kinship, calculée
* à l'aide de IBD_length
* Repose sur la fonction suivante :

relatednessLength(zygote & Z1, zygote & Z2);

* qui calcule la somme des longueurs de segments x le degré d'apparentement 
* sur le segment [peut être perfectible...]

NumericMatrix fraternity_matrix(std::vector<zygote> & ZYG)

* Renvoie la matrice des proportions de génomes partagées IBD 2


NumericMatrix ibd_matrix(std::vector<mosaic> & HAP)

* Celle là renvoie la proportion d'IBD entre haplotypes !
* [voir dans make_haps]


XPtr<matrix4> zygote_to_bed_matrix(ZYG, mapB)

* Cette fonction fait à peu près ce que son nom indique (drop_to_matrix4 aurait été mieux)
* mapB est une "mapped bed matrix" d'haplotypes
* La matrix4 haplotypes est une matrix4 d'haplotypes codés 0, 1
*
* NOTE TECHNIQUE
* la fonction utilise push_genotypes_at_cursor(std::vector<zygote> & x, T1 & allele_at_haplo, T2 & genotypes)
* définie dans push_genotypes_at_cursor.h
* Qui suppose que allele_at_haplo est un vecteur des allèles portés par les divers haplotypes "source" à la position
* courante et genotypes est n'importe quoi qui a une function push_back : un vecteur d'entiers ou bien un SNP_push_back
* 
* La classe SNP_push_back définie dans push_m4_row.h 
* permet de remplir une ligne d'une matrix4 par des push_back
*
* Dans le même fichier la fonction push_m4_row permet de pusher les valeurs 
* contenues dans une ligne d'une matrix4 vers un vecteur d'entiers 

####################################################################

bool HBD_at_point(zygote & Z)
* test si les deux haplotypes sont HBD au point défini par le curseur
* note : la fonction ne teste pas que les deux curseurs sont au même endroit...


double HBD_length(zygote & Z)
* idem IBD_length, mais pour la longueur HBD

####################################################################

# fait ce que son nom indique, en finissant par un drop to bed matrix 
List cousins_1stdegree(int n, double tile_length, XPtr<matrix4> Haplos, IntegerVector chr, NumericVector dist,
                       bool kinship = false, bool fraternity = false)


 make_inds.cpp
 make_pairs.cpp
 nuclear_families.cpp


population(int n0, int nGen, int keep, double lambda,
                double tile_length, XPtr<matrix4> Haplos, IntegerVector chr, NumericVector dist,
                bool kinship = false, bool fraternity = false)

Fait une simulation en forward time avec le nombre d'enfants pris dans une loi de Poisson 
Fini par un drop to bed matrix

##############################################################

dans segments.h : définition de la classe 'segments' 
class segments {
  public:
  std::vector<int> chr;
  std::vector<double> beg;
  std::vector<double> end;
};

segments HBD_segments(zygote & Z) : renvoie un objet segments qui contient les segments HBD

* [appelée dans make_indreds où le résultat est transformé en data frame]




##############################################################

Fonctions utilisées pour la génération du VCF [voir commentaire dans le code]
GT.cpp : GT(NumericMatrix phtab)
CQ.cpp : GQ(NumericMatrix phtab)
std::string pasteVcfElts(CharacterVector genoN, IntegerVector rd, IntegerVector rd2, IntegerVector rd3,
                         IntegerVector GQ, NumericMatrix phtab)


Une fonction qui récupère un vecteur de génotypes...
IntegerVector getGenoVector(XPtr<matrix4> pA, int snpIndex, bool Rindex = true)

##############################################################

Y a des fonctions pour le modèle de la liabilité... c'est un peu le bordel dedans, ça serait à reprendre

liabilitySelectedInds(std::vector<mozza::zygote> & ZYG, std::vector<double> & Graw, std::vector<double> & G, std::vector<double> & E,
                      int n_target, int n_haps, double length_tiles, double minimum_liability, double maximum_liability,
                      mozza::phenotyper<IntegerVector, NumericVector> & PT)

introduction de Demes où les haplotypes ont des fréquences différentes dans
liabilitySelectedIndsProbs( ... )


#####################################################
### vague d'ajout de fonctions "interface avec R" ###

# HAPLOTYPES:

Ces deux fonctions renvoient un pointeur (XPtr) vers un haplotype, en appelant 
le constructeur correspondant

haplotype(int ntiles, double mean_length_tiles = 20) 
haplotype_probs(NumericVector probaTiles, double mean_length_tiles = 20)

# ZYGOTES:

Appelle les constructeurs de zygotes, renvoie un XPtr

zygote(int ntiles, double mean_length_tiles = 20)
zygote_probs(NumericVector probaTiles, double mean_length_tiles = 20)

# KINSHIP MATRIX

kinship_matrix_(List L) prend une liste de XPtr de zygotes
Je n'ai pas réussi à éviter la copie dans un vecteur de pointeurs de zygotes
Voir les essais dans getZygote.h et les aménagemements dans kinship_matrix.h
Peut-être est-ce possible...

# VOIR ET MODIFIER LES OBJETS
# peek functions:

Construction d'un data frame avec colonnes chr, pos, tile. 
Pos correspond à "bpoints" et tile à "tile".
Dernère pos en fin de chromosome, le numero de tuile correspond à ce qui est présent
entre [le début du chr/la position précédent] et la position donnée.

haplotype_peek(mozza::mosaic & M)
haplotype_peek(Rcpp::XPtr<mozza::mosaic> xpm) 

renvoie une liste de deux data frame, un pour chacun des deux haplotypes

zygote_peek(Rcpp::XPtr<mozza::zygote> xpz) 

- fonctions haplo_drop_tile_index et zygote_drop_tile_index : récupérer le numéro 
de tuile à une série de positions données

- fonctions haplo_group_by_tile_index et zygote_group_by_tile_index [pour Fabien]
création de groupes d'indices qui sont dans la même tuile...

# poke functions:

Modifient les objets 'in place', créées pour le script de simus de Fabien

Template 'niveau C++' :
void haplotype_poke(mozza::mosaic & M, intVec tile_index, intVec tile, bool Rindex = true)

remplace la tuile dont l'indice (en partant du premier chromosome) est donné dans tile_index
par la valeur données dans tile
Rindex = true si les index commencent à 1
la fonction suppose que tile_index est trié dans l'ordre croissant

Interface avec R :
void haplotype_poke(Rcpp::XPtr<mozza::mosaic> xpm, IntegerVector tile_index, IntegerVector tile)
void zygote_poke(Rcpp::XPtr<mozza::zygote> xpz, IntegerVector tile_index1, IntegerVector tile1, IntegerVector tile_index2, IntegerVector tile2)



